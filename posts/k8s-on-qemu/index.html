<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><title>Kubernetes in Qemu | Jorge Andres Dev (dot) Com</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="Introduction
The goal of this excercise is to have a full kubernetes cluster installation on top of heterogeneous qemu virtual machines as worker nodes.
We&rsquo;ll need to:

Prepare the host and virtual network
Create the virtual machines
Install k8s worker and create a control plane
Join worker vms to the cluster

Something similar to:

Each worker will be a different Virtual Machine running Debian GNU/Linux on Qemu.
Preparing the host and virtual network
Options like VDE and TUN/TAP can be considered here for virtual networking, we&rsquo;ll be using the latter:"><meta name=generator content="Hugo 0.152.2"><meta name=robots content="index, follow"><link rel=stylesheet href=andrestafur.github.io/ananke/css/main.min.efe4d852f731d5d1fbb87718387202a97aafd768cdcdaed0662bbe6982e91824.css><link rel=canonical href=andrestafur.github.io/posts/k8s-on-qemu/><meta property="og:url" content="andrestafur.github.io/posts/k8s-on-qemu/"><meta property="og:site_name" content="Jorge Andres Dev (dot) Com"><meta property="og:title" content="Kubernetes in Qemu"><meta property="og:description" content="Introduction The goal of this excercise is to have a full kubernetes cluster installation on top of heterogeneous qemu virtual machines as worker nodes.
We’ll need to:
Prepare the host and virtual network Create the virtual machines Install k8s worker and create a control plane Join worker vms to the cluster Something similar to:
Each worker will be a different Virtual Machine running Debian GNU/Linux on Qemu.
Preparing the host and virtual network Options like VDE and TUN/TAP can be considered here for virtual networking, we’ll be using the latter:"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-08-15T20:22:05-05:00"><meta property="article:modified_time" content="2025-08-15T20:22:05-05:00"><meta property="article:tag" content="Kubernetes"><meta property="article:tag" content="Qemu"><meta itemprop=name content="Kubernetes in Qemu"><meta itemprop=description content="Introduction The goal of this excercise is to have a full kubernetes cluster installation on top of heterogeneous qemu virtual machines as worker nodes.
We’ll need to:
Prepare the host and virtual network Create the virtual machines Install k8s worker and create a control plane Join worker vms to the cluster Something similar to:
Each worker will be a different Virtual Machine running Debian GNU/Linux on Qemu.
Preparing the host and virtual network Options like VDE and TUN/TAP can be considered here for virtual networking, we’ll be using the latter:"><meta itemprop=datePublished content="2025-08-15T20:22:05-05:00"><meta itemprop=dateModified content="2025-08-15T20:22:05-05:00"><meta itemprop=wordCount content="1219"><meta itemprop=keywords content="Kubernetes,Qemu"><meta name=twitter:card content="summary"><meta name=twitter:title content="Kubernetes in Qemu"><meta name=twitter:description content="Introduction The goal of this excercise is to have a full kubernetes cluster installation on top of heterogeneous qemu virtual machines as worker nodes.
We’ll need to:
Prepare the host and virtual network Create the virtual machines Install k8s worker and create a control plane Join worker vms to the cluster Something similar to:
Each worker will be a different Virtual Machine running Debian GNU/Linux on Qemu.
Preparing the host and virtual network Options like VDE and TUN/TAP can be considered here for virtual networking, we’ll be using the latter:"></head><body class="ma0 avenir bg-near-white production"><header><div class=bg-black><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l center items-center justify-between"><a href=../../ class="f3 fw2 hover-white white-90 dib no-underline">Jorge Andres Dev (dot) Com</a><div class="flex-l items-center"><ul class="pl0 mr3"><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white white-90 no-underline" href=../../ title="Home page">Home</a></li><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white white-90 no-underline" href=../../posts/ title="Posts page">Posts</a></li></ul><div class=ananke-socials></div></div></div></nav></div></header><main class=pb7 role=main><article class="flex-l mw8 center ph3 flex-wrap justify-between"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked ttu">Posts</aside><div id=sharing class="mt3 ananke-socials"></div><h1 class="f1 athelas mt3 mb1">Kubernetes in Qemu</h1><time class="f6 mv4 dib tracked" datetime=2025-08-15T20:22:05-05:00>August 15, 2025</time></header><div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><h1 id=introduction>Introduction</h1><p>The goal of this excercise is to have a full kubernetes cluster installation on top of heterogeneous qemu virtual machines as worker nodes.</p><p>We&rsquo;ll need to:</p><ol><li>Prepare the host and virtual network</li><li>Create the virtual machines</li><li>Install k8s worker and create a control plane</li><li>Join worker vms to the cluster</li></ol><p>Something similar to:</p><p><img src=intro.svg alt="Virtual Network"></p><p>Each worker will be a different Virtual Machine running Debian GNU/Linux on Qemu.</p><h1 id=preparing-the-host-and-virtual-network>Preparing the host and virtual network</h1><p>Options like VDE and TUN/TAP can be considered here for virtual networking, we&rsquo;ll be using the latter:</p><p><img src=virtual-network.png alt="Virtual Network"></p><p><em>Note: Bridge and TAP devices are non-persistent and are removed after reboot. If some persistence is required it is advised to use the qemu bridge helper.</em></p><h2 id=step-1-setup-a-network-bridge>Step 1. Setup a network bridge</h2><p><em>A bridge is like a virtualized network switch</em></p><p>First we create a bridge and assing an IP address to it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ip link add vmbridge0 type bridge
</span></span><span style=display:flex><span>ip addr add 192.168.100.1/24 dev vmbridge0
</span></span><span style=display:flex><span>ip link set vmbridge0 up
</span></span></code></pre></div><p>Add the following line to /etc/qemu/bridge.conf</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>allow vmbridge0
</span></span></code></pre></div><h2 id=step-2-setup-a-ligthweight-dhcp>Step 2. Setup a Ligthweight DHCP</h2><p>We are gonna use dnsmasq with the following configuration:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#/etc/dnsmasq.conf</span>
</span></span><span style=display:flex><span>interface<span style=color:#f92672>=</span>vmbridge0  <span style=color:#75715e># Just on the bridge interface</span>
</span></span><span style=display:flex><span>bind-interfaces      <span style=color:#75715e># Keep it bound only to it</span>
</span></span><span style=display:flex><span>dhcp-range<span style=color:#f92672>=</span>192.168.100.50,192.168.100.100,12h <span style=color:#75715e># Range of dynamic IPs and the lease</span>
</span></span><span style=display:flex><span>dhcp-option<span style=color:#f92672>=</span>3,192.168.100.1 <span style=color:#75715e># Default gateway</span>
</span></span><span style=display:flex><span>dhcp-option<span style=color:#f92672>=</span>6,192.168.100.1 <span style=color:#75715e># Default DNS</span>
</span></span></code></pre></div><p>Optionally add static ips to the config so we can easily identify our vms:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>dhcp-host<span style=color:#f92672>=</span>52:54:00:00:00:01,worker0,192.168.100.50
</span></span><span style=display:flex><span>dhcp-host<span style=color:#f92672>=</span>52:54:00:00:00:02,worker1,192.168.100.51
</span></span><span style=display:flex><span>dhcp-host<span style=color:#f92672>=</span>52:54:00:00:00:03,worker2,192.168.100.52
</span></span><span style=display:flex><span>dhcp-host<span style=color:#f92672>=</span>52:54:00:00:00:04,worker3,192.168.100.53
</span></span><span style=display:flex><span>dhcp-host<span style=color:#f92672>=</span>52:54:00:00:00:05,worker4,192.168.100.54
</span></span></code></pre></div><p>Enable the dnsmasq service:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo systemctl enable --now dnsmasq
</span></span></code></pre></div><h2 id=step-3-tap-interfaces>Step 3. TAP interfaces</h2><p><em>Note: this step can be done through the qemu bridge helper so the tap interfaces become dynamic. We&rsquo;ll use the static approach thiss time.</em></p><p>Make sure the TUN kernel module is present, also make it persistent across reboots:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>modprobe tun
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>&#34;tun&#34;</span> | sudo tee /etc/modules-load.d/tun.conf
</span></span></code></pre></div><p>Create a tap interface <strong>per VM</strong>, link them to the bridge, and bring them up:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#66d9ef>for</span> i in <span style=color:#f92672>{</span>0..4<span style=color:#f92672>}</span>; <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  ip tuntap add dev tap<span style=color:#e6db74>${</span>i<span style=color:#e6db74>}</span> mode tap user $USER
</span></span><span style=display:flex><span>  ip link set tap<span style=color:#e6db74>${</span>i<span style=color:#e6db74>}</span> master vmbridge0
</span></span><span style=display:flex><span>  ip link set tap<span style=color:#e6db74>${</span>i<span style=color:#e6db74>}</span> up
</span></span><span style=display:flex><span><span style=color:#66d9ef>done</span>
</span></span></code></pre></div><h2 id=step-4-nat-access-from-the-host>Step 4. NAT access from the Host</h2><p>Enable ip forwarding in the host:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo sysctl -w net.ipv4.ip_forward<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p>Configure iptables to forward traffic to the bridge:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo iptables -t nat -A POSTROUTING -o wlan0 -j MASQUERADE
</span></span><span style=display:flex><span>sudo iptables -A FORWARD -i wlan0 -o vmbridge0 -m state --state RELATED,ESTABLISHED -j ACCEPT
</span></span><span style=display:flex><span>sudo iptables -A FORWARD -i vmbridge0 -o wlan0 -j ACCEPT
</span></span></code></pre></div><h1 id=creating-the-virtual-machines>Creating the Virtual Machines</h1><h2 id=step-1-cow-disk>Step 1. COW Disk</h2><p>Create a copy-on-write VM Disk, we are gonna use 8G (similar to AMI convention), this is not gonna use the whole physical space but it is what will be reported to the virtualized OS by qemu:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>qemu-img create -f qcow2 vm0.img 8G
</span></span></code></pre></div><h2 id=step-2-debian-setup---manual-image>Step 2. Debian setup - Manual Image</h2><p>Here we can run a preseeded Debian image, a Debian cloud-image or a manual installation. We&rsquo;ll be going with manual installation:</p><ol><li>Download the latest debian netinstall iso from the official debian page.</li><li>Run a vm using the iso as cdrom media, the cow disk as storage, and the tap0 as network interface:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>  qemu-system-x86_64 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -m <span style=color:#ae81ff>2048</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -smp <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -enable-kvm <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -hda vm0.img <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -cdrom debian.iso <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -netdev tap,id<span style=color:#f92672>=</span>net0,ifname<span style=color:#f92672>=</span>tap0,script<span style=color:#f92672>=</span>no,downscript<span style=color:#f92672>=</span>no <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -device virtio-net-pci,netdev<span style=color:#f92672>=</span>net0,romfile<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;&#34;</span>,mac<span style=color:#f92672>=</span>52:54:00:00:00:01 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -display default <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -serial unix:/tmp/vm0.sock,server,nowait <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -name <span style=color:#e6db74>&#34;vm0&#34;</span>
</span></span></code></pre></div><p>Proceed with the installation using worker0 as the hostname, swap partition won&rsquo;t be required, The default behavior of a kubelet is to fail to start if an active swap is detected on the vm.</p><ul><li>Install openssh server.</li><li>If you want to use a SCM software, install the necessary tooling (agents, deps, etc). For example: Ansible requires python.</li></ul><h2 id=step-3-ssh-access>Step 3. SSH Access</h2><p>On the host, generate a SSH key</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Bash data-lang=Bash><span style=display:flex><span>ssh-keygen -t ed25519 -C <span style=color:#e6db74>&#34;k8s-vms&#34;</span> -f ~/.ssh/k8s_vms
</span></span></code></pre></div><p>Copy the public key <em>~/.ssh/k8s_vms.pub</em> into the vm with any user created (except root).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Bash data-lang=Bash><span style=display:flex><span>ssh-copy-id -i .ssh/k8s_vms.pub   user@192.168.100.50
</span></span></code></pre></div><p>Login to the machine using the other key:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ssh -i k8s_vms_ssh_key user@192.168.100.50
</span></span></code></pre></div><h1 id=setting-up-cri-o-and-kubernetes>Setting up CRI-O and Kubernetes</h1><p>Install curl and friends</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo apt-get update
</span></span><span style=display:flex><span>sudo apt-get install -y apt-transport-https ca-certificates curl gpg util-linux
</span></span></code></pre></div><h2 id=step-1-install-cri-o>Step 1. Install CRI-O</h2><p>Add the CRI-O Repository</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>export CRIO_VERSION<span style=color:#f92672>=</span>v1.33
</span></span><span style=display:flex><span>curl -fsSL https://download.opensuse.org/repositories/isv:/cri-o:/stable:/$CRIO_VERSION/deb/Release.key | gpg --dearmor -o /etc/apt/keyrings/cri-o-apt-keyring.gpg
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>&#34;deb [signed-by=/etc/apt/keyrings/cri-o-apt-keyring.gpg] https://download.opensuse.org/repositories/isv:/cri-o:/stable:/</span>$CRIO_VERSION<span style=color:#e6db74>/deb/ /&#34;</span> | tee /etc/apt/sources.list.d/cri-o.list
</span></span></code></pre></div><p>Install the CRI-O runtime</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>apt-get update
</span></span><span style=display:flex><span>apt-get install -y cri-o
</span></span></code></pre></div><p>Enable the service</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>systemctl enable crio.service
</span></span><span style=display:flex><span>systemctl start crio.service
</span></span></code></pre></div><p>Check crictl:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>crictl ps
</span></span></code></pre></div><h2 id=step-2-install-kubeadm-kubelet-and-kubectl>Step 2. Install kubeadm, kubelet and kubectl</h2><p>kubeadm:</p><p>kubelet:</p><p>kubectl:</p><p>Follow the latest steps here: <a href=https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/>https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/</a>, in summary:</p><p>Download the GPG key for k8s and add the repo:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.33/deb/Release.key | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>&#39;deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.33/deb/ /&#39;</span> | sudo tee /etc/apt/sources.list.d/kubernetes.list
</span></span></code></pre></div><p>And finally install the kubelet, kubeadm and kubectl</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo apt update
</span></span><span style=display:flex><span>sudo apt install -y kubeadm kubelet kubectl
</span></span></code></pre></div><p>Make sure forwarding is enabled in /etc/sysctl.conf:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>net.ipv4.ip_forward<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p>Make sure the following modules are present</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>echo -e <span style=color:#e6db74>&#34;br_netfilter\noverlay\nvxlan&#34;</span> | sudo tee /etc/modules-load.d/k8s.conf
</span></span></code></pre></div><h2 id=step-3-vm-overlays>Step 3. VM overlays</h2><p>Rename vm0.img to base image and make it read only:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>mv vm0.img base.img  
</span></span><span style=display:flex><span>chmod <span style=color:#ae81ff>444</span> base.img
</span></span></code></pre></div><p>Create an overlay from the base image</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>qemu-img create -f qcow2 -b base.img -F qcow2 vm0.img
</span></span><span style=display:flex><span>qemu-img create -f qcow2 -b base.img -F qcow2 vm1.img
</span></span><span style=display:flex><span>qemu-img create -f qcow2 -b base.img -F qcow2 vm2.img
</span></span><span style=display:flex><span>qemu-img create -f qcow2 -b base.img -F qcow2 vm3.img
</span></span><span style=display:flex><span>qemu-img create -f qcow2 -b base.img -F qcow2 vm4.img
</span></span></code></pre></div><p>Check the overlay specially that it points to the backing image</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>qemu-img info vm0.img
</span></span></code></pre></div><h2 id=step-4-create-the-other-instances>Step 4. Create the other instances</h2><p>Run the VMs headless using the overlays, one for each vm:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/bin/bash
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i in <span style=color:#f92672>{</span>0..4<span style=color:#f92672>}</span>; <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  qemu-system-x86_64 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -m <span style=color:#ae81ff>2048</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -smp <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -enable-kvm <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -hda vm<span style=color:#e6db74>${</span>i<span style=color:#e6db74>}</span>.img <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -netdev tap,id<span style=color:#f92672>=</span>net0,ifname<span style=color:#f92672>=</span>tap<span style=color:#e6db74>${</span>i<span style=color:#e6db74>}</span>,script<span style=color:#f92672>=</span>no,downscript<span style=color:#f92672>=</span>no <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -device virtio-net-pci,netdev<span style=color:#f92672>=</span>net0,romfile<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;&#34;</span>,mac<span style=color:#f92672>=</span>52:54:00:00:00:0<span style=color:#66d9ef>$((</span>i+1<span style=color:#66d9ef>))</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -display none <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -daemonize <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -serial unix:/tmp/vm<span style=color:#e6db74>${</span>i<span style=color:#e6db74>}</span>.sock,server,nowait <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -name <span style=color:#e6db74>&#34;vm</span><span style=color:#e6db74>${</span>i<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span> &amp;
</span></span><span style=display:flex><span><span style=color:#66d9ef>done</span>
</span></span></code></pre></div><p>Check the ip addresses of all the vms</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ip neigh show dev vmbridge0
</span></span></code></pre></div><h2 id=step-5-creating-control-plane>Step 5. Creating control plane</h2><p>SSH login into the first worker and initialize the cluster with kubeadm</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo kubeadm init --pod-network-cidr<span style=color:#f92672>=</span>10.244.0.0/16
</span></span></code></pre></div><p>This operation will take some minutes. after it finishes it will print the .kube/config and the command to join workers:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>  mkdir -p $HOME/.kube
</span></span><span style=display:flex><span>  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
</span></span><span style=display:flex><span>  sudo chown <span style=color:#66d9ef>$(</span>id -u<span style=color:#66d9ef>)</span>:<span style=color:#66d9ef>$(</span>id -g<span style=color:#66d9ef>)</span> $HOME/.kube/config
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubeadm join 192.168.100.50:6443 --token 1fg7bq.zyqqo6y7wdja4m1u <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>	--discovery-token-ca-cert-hash sha256:59dfdb80dbbafb507add051ef5321630ea428028b291990cc066d9f159b4f557 
</span></span></code></pre></div><p>Check the cluster status with:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl get nodes
</span></span></code></pre></div><h2 id=step-6-cni---flannel>Step 6. CNI - Flannel</h2><p>CNI: Container Network Interface</p><p>CNI (Container Network Interface), a Cloud Native Computing Foundation project, consists of a specification and libraries for writing plugins to configure network interfaces in Linux and Windows containers, along with a number of supported plugins. CNI concerns itself only with network connectivity of containers and removing allocated resources when the container is deleted. Because of this focus, CNI has a wide range of support and the specification is simple to implemen
(<a href=https://www.cni.dev/>https://www.cni.dev/</a>)</p><p>There are different options here, the most populars are Flannel and Calico, we&rsquo;ll go with flannel for this one:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml
</span></span></code></pre></div><h2 id=step-7-adding-worker-nodes>Step 7. Adding worker nodes</h2><p>In each of the other vms run the command printed when the cluster was initialized:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubeadm join 192.168.100.50:6443 --token 1fg7bq.zyqqo6y7wdja4m1u <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>	--discovery-token-ca-cert-hash sha256:59dfdb80dbbafb507add051ef5321630ea428028b291990cc066d9f159b4f557 
</span></span></code></pre></div><p>If the sha/token is lost, it can be recreated with the following command:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubeadm token create --print-join-command
</span></span></code></pre></div><p>This step will take some minutes.</p><p>Finally use kubectl to check the worker nodes status:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl get nodes
</span></span></code></pre></div><p>Final Result from k9s:</p><p><img src=result.png alt="End Result"></p><h2 id=extra-setup-ansible-to-manage-the-vms>Extra. Setup Ansible to manage the VM&rsquo;s</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-toml data-lang=toml><span style=display:flex><span>[<span style=color:#a6e22e>debian_vms</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>vm0</span> <span style=color:#a6e22e>ansible_host</span>=<span style=color:#ae81ff>192.168</span>.<span style=color:#ae81ff>100.50</span> <span style=color:#a6e22e>ansible_user</span>=<span style=color:#a6e22e>user</span> <span style=color:#a6e22e>ansible_ssh_private_key_file</span>=..<span style=color:#960050;background-color:#1e0010>/</span><span style=color:#a6e22e>k8s_vms_ssh_key</span> 
</span></span><span style=display:flex><span><span style=color:#a6e22e>vm1</span> <span style=color:#a6e22e>ansible_host</span>=<span style=color:#ae81ff>192.168</span>.<span style=color:#ae81ff>100.51</span> <span style=color:#a6e22e>ansible_user</span>=<span style=color:#a6e22e>user</span> <span style=color:#a6e22e>ansible_ssh_private_key_file</span>=..<span style=color:#960050;background-color:#1e0010>/</span><span style=color:#a6e22e>k8s_vms_ssh_key</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>vm2</span> <span style=color:#a6e22e>ansible_host</span>=<span style=color:#ae81ff>192.168</span>.<span style=color:#ae81ff>100.52</span> <span style=color:#a6e22e>ansible_user</span>=<span style=color:#a6e22e>user</span> <span style=color:#a6e22e>ansible_ssh_private_key_file</span>=..<span style=color:#960050;background-color:#1e0010>/</span><span style=color:#a6e22e>k8s_vms_ssh_key</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>vm3</span> <span style=color:#a6e22e>ansible_host</span>=<span style=color:#ae81ff>192.168</span>.<span style=color:#ae81ff>100.53</span> <span style=color:#a6e22e>ansible_user</span>=<span style=color:#a6e22e>user</span> <span style=color:#a6e22e>ansible_ssh_private_key_file</span>=..<span style=color:#960050;background-color:#1e0010>/</span><span style=color:#a6e22e>k8s_vms_ssh_key</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>vm4</span> <span style=color:#a6e22e>ansible_host</span>=<span style=color:#ae81ff>192.168</span>.<span style=color:#ae81ff>100.54</span> <span style=color:#a6e22e>ansible_user</span>=<span style=color:#a6e22e>user</span> <span style=color:#a6e22e>ansible_ssh_private_key_file</span>=..<span style=color:#960050;background-color:#1e0010>/</span><span style=color:#a6e22e>k8s_vms_ssh_key</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>debian_vms</span><span style=color:#960050;background-color:#1e0010>:</span><span style=color:#a6e22e>vars</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>ansible_user</span>=<span style=color:#a6e22e>user</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ansible_become</span>=<span style=color:#66d9ef>true</span>
</span></span></code></pre></div><ul class=pa0><li class="list di"><a href=../../tags/kubernetes/ class="link f5 grow br-pill ba ph3 pv2 mb2 dib black sans-serif no-underline">Kubernetes</a></li><li class="list di"><a href=../../tags/qemu/ class="link f5 grow br-pill ba ph3 pv2 mb2 dib black sans-serif no-underline">Qemu</a></li></ul><div class="mt6 instapaper_ignoref"></div></div><aside class="w-30-l mt6-l"></aside></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white white-70 dn dib-ns pv2 ph3 no-underline" href=andrestafur.github.io/>&copy; Jorge Andres Dev (dot) Com 2025</a><div><div class=ananke-socials></div></div></div></footer></body></html>